@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

/* Theme variables are handled by Tailwind CSS v4 automatically */

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

@layer utilities {
  .copyleft {
    display: inline-block;
    transform: scaleX(-1);
  }
}

/* Liquid Glass Effect - outside layer for higher specificity */
.glass {
  position: relative !important;
  background: transparent !important;
  overflow: hidden !important;
  isolation: isolate !important;
}

.glass > * {
  position: relative !important;
  z-index: 1 !important;
}

.glass::before {
  content: '' !important;
  position: absolute !important;
  inset: 0 !important;
  z-index: -1 !important;
  overflow: hidden !important;
  border-radius: inherit !important;
  box-shadow: 
    inset 2px 2px 0px -2px rgba(255, 255, 255, 0.7), 
    inset 0 0 3px 1px rgba(255, 255, 255, 0.7) !important;
  background-color: rgb(255 255 255 / 50%) !important;
}

.glass::after {
  content: '' !important;
  position: absolute !important;
  z-index: -1 !important;
  inset: 0 !important;
  border-radius: inherit !important;
  backdrop-filter: blur(0px) !important;
  filter: url(#liquid-glass) !important;
  overflow: hidden !important;
  isolation: isolate !important; /* Default: isolate for hero card */
}

/* MOBILE OPTIMIZATION: Disable expensive SVG filters on mobile devices */
/* Use simplified backdrop-filter only to prevent Three.js compositing issues */
@media (hover: none) and (pointer: coarse) {
  .glass::after {
    /* Remove expensive SVG filter on mobile - causes compositing issues with Three.js */
    filter: none !important;
    /* Use simple backdrop-filter instead for glass effect */
    backdrop-filter: blur(8px) saturate(180%) !important;
    -webkit-backdrop-filter: blur(8px) saturate(180%) !important;
  }
  
  /* Disable filter layer entirely on mobile - JavaScript already skips creation, but ensure CSS doesn't apply */
  .glass-filter-layer-fixed {
    display: none !important;
    filter: none !important;
  }
  
  /* For glass cards in parallax on mobile, use simple backdrop-filter */
  .glass-in-parallax::after,
  .parallax-element .glass::after,
  .parallax-element > .glass::after {
    filter: none !important;
    backdrop-filter: blur(8px) saturate(180%) !important;
    -webkit-backdrop-filter: blur(8px) saturate(180%) !important;
  }
}

/* Dark mode variant */
.dark .glass::before {
  box-shadow: 
    inset 2px 2px 0px -2px rgba(255, 255, 255, 0.1), 
    inset 0 0 3px 1px rgba(255, 255, 255, 0.1) !important;
  background-color: rgb(255 255 255 / 10%) !important;
}

/* Glass variants */
.glass-sm::before {
  box-shadow: 
    inset 1px 1px 0px -1px rgba(255, 255, 255, 0.6), 
    inset 0 0 2px 1px rgba(255, 255, 255, 0.6) !important;
}

.glass-lg::before {
  box-shadow: 
    inset 3px 3px 0px -3px rgba(255, 255, 255, 0.8), 
    inset 0 0 4px 2px rgba(255, 255, 255, 0.8) !important;
}

/* Hover effects */
.glass-hover:hover::before {
  background-color: rgb(255 255 255 / 25%) !important;
  box-shadow: 
    inset 2px 2px 0px -2px rgba(255, 255, 255, 0.8), 
    inset 0 0 4px 2px rgba(255, 255, 255, 0.8) !important;
}

.dark .glass-hover:hover::before {
  background-color: rgb(255 255 255 / 15%) !important;
  box-shadow: 
    inset 2px 2px 0px -2px rgba(255, 255, 255, 0.15), 
    inset 0 0 4px 2px rgba(255, 255, 255, 0.15) !important;
}

@font-face {
  font-family: "RedHatTextVar";
  src: url("/fonts/subset/RedHatTextVarLatinSubsetBasic.woff2") format("woff2-variations");
  font-weight: 400 700;
  font-display: swap;
}

@font-face {
  font-family: "RemiliaMincho";
  src: url("/fonts/RemiliaMincho-Regular.otf") format("opentype");
  font-weight: 400;
  font-display: swap;
}

body {
  font-family: "RedHatTextVar", var(--font-geist-sans), sans-serif;
}

.font-remilia {
  font-family: "RemiliaMincho", serif;
}

.bg-tartan-blur {
  background-image: url('/patterns/remiliatartan.jpeg');
  background-size: 250px;
  filter: blur(15px);
  /* Opacity controlled dynamically via inline styles in InitialSplash */
}

/* Loader keyframes */
@keyframes fillBar {
  0% { width: 0%; }
  100% { width: 100%; }
}

.animate-loader {
  animation: fillBar 1s forwards ease-out;
}

@media (prefers-reduced-motion: reduce) {
  .animate-loader {
    animation: none;
    width: 100%;
  }
}

/* NProgress overrides */
@import "nprogress/nprogress.css";

#nprogress {
  pointer-events: none;
}

#nprogress .bar {
  background: #B71E34 !important;
  height: 3px !important;
}

#nprogress .peg {
  box-shadow: none !important;
}

@media (prefers-reduced-motion: reduce) {
  #nprogress .bar {
    transition: none !important;
  }
}

/* Link underline slide animation */
a.link-underline {
  position: relative;
  text-decoration: none;
}

a.link-underline::after {
  content: '';
  position: absolute;
  left: 0;
  bottom: 0;
  width: 0%;
  height: 1px;
  background: currentColor;
  transition: width 0.25s ease;
}

a.link-underline:hover::after {
  width: 100%;
}

@media (prefers-reduced-motion: reduce) {
  a.link-underline::after {
    transition: none;
  }
}

/* Prism â€” Solarized Dark variant */
pre[class*="language-"] {
  border-radius: 0.375rem;
  padding: 1rem;
  overflow-x: auto;
  font-size: 0.875rem;
  line-height: 1.625;
  font-family: ui-monospace, SFMono-Regular, "SF Mono", Consolas, "Liberation Mono", Menlo, monospace;
  background: #002b36; /* base03 */
  color: #839496;     /* base0  */
}

/* Tokens */
.token.comment, .token.prolog, .token.doctype, .token.cdata {
  color: #586e75; /* base01 */
}
.token.punctuation { color: #93a1a1; }
.token.property, .token.tag, .token.constant, .token.symbol, .token.deleted {
  color: #dc322f; /* red */
}
.token.boolean, .token.number { color: #d33682; /* magenta */ }
.token.selector, .token.attr-name, .token.string, .token.char, .token.builtin, .token.inserted {
  color: #2aa198; /* cyan */
}
.token.operator, .token.entity, .token.url, .language-css .token.string, .style .token.string, .token.variable {
  color: #cb4b16; /* orange */
}
.token.atrule, .token.attr-value, .token.function, .token.class-name {
  color: #268bd2; /* blue */
}
.token.keyword { color: #859900; /* green */ }
.token.regex, .token.important {
  color: #b58900; /* yellow */
}
.token.bold { font-weight: bold; }
.token.italic { font-style: italic; }
.token.entity { cursor: help; }

/* Embed code block within prose */
@layer utilities {
  .prose :where(pre):not(:where([class~="not-prose"] *)) {
    margin-top: 1.5rem;
    margin-bottom: 1.5rem;
  }

  /* Smooth scroll behavior */
  html {
    scroll-behavior: smooth;
  }

  @media (prefers-reduced-motion: reduce) {
    html {
      scroll-behavior: auto;
    }
  }

  /* Awwwards-style scroll snap for precise positioning */
  html {
    scroll-snap-type: y mandatory;
  }

  .scroll-snap-section {
    scroll-snap-align: start;
    scroll-snap-stop: always;
  }

  @media (prefers-reduced-motion: reduce) {
    html {
      scroll-snap-type: none;
    }
  }

  /* Ensure sticky headers work properly - no overflow clipping */
  #services,
  #projects {
    overflow: visible;
  }

  /* Ensure sticky positioning works within sections */
  #services > div[style*="position: sticky"],
  #projects > div[style*="position: sticky"] {
    position: sticky !important;
  }


  /* GPU acceleration for scroll reveals */
  [style*="translate3d"] {
    transform-style: preserve-3d;
    backface-visibility: hidden;
    -webkit-font-smoothing: antialiased;
  }

  /* LIQUID GLASS FIX: Use fixed-position filter layer for parallax containers */
  /* 
   * KEY INSIGHT: The hero card works because:
   * 1. PageScene is `fixed inset-0 -z-10` (fixed background covering viewport)
   * 2. Hero GlassCard is `relative z-10` with NO transform on it or parents
   * 3. glass::after with `isolation: isolate` and filter can see through to fixed background
   * 
   * PROBLEM: Other cards are inside ParallaxElement with `transform: translate3d(...)`
   * This transform creates a new stacking context. The filter on glass::after can't see
   * the fixed background outside that transformed coordinate space, even with isolation: auto.
   * 
   * SOLUTION: For glass cards inside parallax containers, create a fixed-position filter layer
   * that matches the glass card's position. This layer is positioned relative to the viewport
   * (like the fixed background), so the filter can see and distort the background correctly.
   * The filter layer is created by GlassCard component via JavaScript.
   */
  
  /* Fixed-position filter layer - positioned to match glass card, can see fixed background */
  /* NOTE: This is disabled on mobile via JavaScript and CSS media queries */
  .glass-filter-layer-fixed {
    position: fixed !important;
    z-index: -1 !important; /* Behind everything except fixed background (-10) */
    /* Apply the liquid glass filter */
    filter: url(#liquid-glass) !important;
    /* CRITICAL: Use a very subtle background so filter has something to process */
    /* The filter will distort this and show the background through it */
    background: rgba(255, 255, 255, 0.01) !important; /* Nearly transparent but not completely */
    backdrop-filter: blur(0px) !important;
    /* Match glass card border radius */
    border-radius: 1rem !important;
    /* Don't interfere with pointer events */
    pointer-events: none !important;
    /* Remove isolation so filter can see through to fixed background */
    isolation: auto !important;
    /* Ensure it's behind glass card content but can see background */
    will-change: transform;
    /* Ensure proper compositing with background */
    mix-blend-mode: normal !important;
  }
  
  /* MOBILE: Disable expensive filter layer on touch devices */
  @media (hover: none) and (pointer: coarse) {
    .glass-filter-layer-fixed {
      display: none !important;
      filter: none !important;
    }
  }

  /* Remove filter from glass::after when inside parallax - filter is on fixed layer instead */
  .glass-in-parallax::after,
  .parallax-element .glass::after,
  .parallax-element > .glass::after {
    /* No filter on ::after - filter is applied to fixed-position layer */
    filter: none !important;
    /* Keep other properties for glass effect appearance */
    position: absolute !important;
    z-index: -1 !important;
    isolation: auto !important;
    backdrop-filter: blur(0px) !important;
    background: transparent !important;
    overflow: hidden !important;
    border-radius: inherit !important;
    content: '' !important;
    inset: 0 !important;
  }

  /* Ensure glass element itself doesn't have filter when in parallax */
  /* CRITICAL: The filter layer is at z-index -1 (fixed position), behind everything */
  /* The glass card content needs to be rendered in a separate compositing layer */
  /* so it's not affected by the filter layer's distortion */
  .glass-in-parallax,
  .parallax-element .glass,
  .parallax-element > .glass {
    position: relative !important;
    filter: none !important;
    /* Don't create isolation here - let content be in parent's stacking context */
    /* but ensure it's above the filter layer */
    z-index: auto !important;
  }

  /* CRITICAL: Ensure glass card content creates its own compositing layer */
  /* This isolates it from the filter layer so the filter only affects the background */
  .glass-in-parallax > *,
  .parallax-element .glass > *,
  .parallax-element > .glass > * {
    position: relative !important;
    z-index: 1 !important;
    /* Create new stacking context to isolate from filter layer */
    isolation: isolate !important;
    /* Use will-change to hint browser to create separate compositing layer */
    will-change: transform;
  }

  /* Optimize scroll reveal animations */
  .scroll-reveal-optimized {
    will-change: transform, opacity;
    transform: translateZ(0);
  }

  /* Scroll indicator animations */
  @keyframes bounce-slow {
    0%, 100% {
      transform: translateY(0);
      animation-timing-function: cubic-bezier(0.8, 0, 1, 1);
    }
    50% {
      transform: translateY(-10px);
      animation-timing-function: cubic-bezier(0, 0, 0.2, 1);
    }
  }

  .animate-bounce-slow {
    animation: bounce-slow 2s infinite;
  }

  @media (prefers-reduced-motion: reduce) {
    .animate-bounce-slow {
      animation: none;
    }
  }
}
